"use strict";Object.defineProperties(exports,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}});const a=require("vue");var G=!1;function k(e,c,r){return Array.isArray(e)?(e.length=Math.max(e.length,c),e.splice(c,1,r),r):(e[c]=r,r)}function C(e,c){if(Array.isArray(e)){e.splice(c,1);return}delete e[c]}/*!
  * pinia v2.0.23
  * (c) 2022 Eduardo San Martin Morote
  * @license MIT
  */let j;const $=e=>j=e,K=process.env.NODE_ENV!=="production"?Symbol("pinia"):Symbol();function O(e){return e&&typeof e=="object"&&Object.prototype.toString.call(e)==="[object Object]"&&typeof e.toJSON!="function"}var R;(function(e){e.direct="direct",e.patchObject="patch object",e.patchFunction="patch function"})(R||(R={}));const U=typeof window<"u",L=(process.env.NODE_ENV!=="production"||!1)&&process.env.NODE_ENV!=="test"&&U;function W(e,c){for(const r in c){const o=c[r];if(!(r in e))continue;const i=e[r];O(i)&&O(o)&&!a.isRef(o)&&!a.isReactive(o)?e[r]=W(i,o):e[r]=o}return e}const z=()=>{};function q(e,c,r,o=z){e.push(c);const i=()=>{const p=e.indexOf(c);p>-1&&(e.splice(p,1),o())};return!r&&a.getCurrentInstance()&&a.onUnmounted(i),i}function V(e,...c){e.slice().forEach(r=>{r(...c)})}function x(e,c){e instanceof Map&&c instanceof Map&&c.forEach((r,o)=>e.set(o,r)),e instanceof Set&&c instanceof Set&&c.forEach(e.add,e);for(const r in c){if(!c.hasOwnProperty(r))continue;const o=c[r],i=e[r];O(i)&&O(o)&&e.hasOwnProperty(r)&&!a.isRef(o)&&!a.isReactive(o)?e[r]=x(i,o):e[r]=o}return e}const ee=process.env.NODE_ENV!=="production"?Symbol("pinia:skipHydration"):Symbol();function te(e){return!O(e)||!e.hasOwnProperty(ee)}const{assign:N}=Object;function B(e){return!!(a.isRef(e)&&e.effect)}function J(e,c,r,o){const{state:i,actions:p,getters:_}=c,u=r.state.value[e];let b;function d(){!u&&(process.env.NODE_ENV==="production"||!o)&&(r.state.value[e]=i?i():{});const E=process.env.NODE_ENV!=="production"&&o?a.toRefs(a.ref(i?i():{}).value):a.toRefs(r.state.value[e]);return N(E,p,Object.keys(_||{}).reduce((l,h)=>(process.env.NODE_ENV!=="production"&&h in E&&console.warn(`[\u{1F34D}]: A getter cannot have the same name as another state property. Rename one of them. Found with "${h}" in store "${e}".`),l[h]=a.markRaw(a.computed(()=>{$(r);const y=r._s.get(e);return _[h].call(y,y)})),l),{}))}return b=A(e,d,c,r,o,!0),b.$reset=function(){const l=i?i():{};this.$patch(h=>{N(h,l)})},b}function A(e,c,r={},o,i,p){let _;const u=N({actions:{}},r);if(process.env.NODE_ENV!=="production"&&!o._e.active)throw new Error("Pinia destroyed");const b={deep:!0};process.env.NODE_ENV!=="production"&&!G&&(b.onTrigger=s=>{d?y=s:d==!1&&!n._hotUpdating&&(Array.isArray(y)?y.push(s):console.error("\u{1F34D} debuggerEvents should be an array. This is most likely an internal Pinia bug."))});let d,E,l=a.markRaw([]),h=a.markRaw([]),y;const P=o.state.value[e];!p&&!P&&(process.env.NODE_ENV==="production"||!i)&&(o.state.value[e]={});const I=a.ref({});let F;function H(s){let t;d=E=!1,process.env.NODE_ENV!=="production"&&(y=[]),typeof s=="function"?(s(o.state.value[e]),t={type:R.patchFunction,storeId:e,events:y}):(x(o.state.value[e],s),t={type:R.patchObject,payload:s,storeId:e,events:y});const f=F=Symbol();a.nextTick().then(()=>{F===f&&(d=!0)}),E=!0,V(l,t,o.state.value[e])}const Q=process.env.NODE_ENV!=="production"?()=>{throw new Error(`\u{1F34D}: Store "${e}" is built using the setup syntax and does not implement $reset().`)}:z;function X(){_.stop(),l=[],h=[],o._s.delete(e)}function M(s,t){return function(){$(o);const f=Array.from(arguments),m=[],D=[];function Y(v){m.push(v)}function Z(v){D.push(v)}V(h,{args:f,name:s,store:n,after:Y,onError:Z});let S;try{S=t.apply(this&&this.$id===e?this:n,f)}catch(v){throw V(D,v),v}return S instanceof Promise?S.then(v=>(V(m,v),v)).catch(v=>(V(D,v),Promise.reject(v))):(V(m,S),S)}}const w=a.markRaw({actions:{},getters:{},state:[],hotState:I}),T={_p:o,$id:e,$onAction:q.bind(null,h),$patch:H,$reset:Q,$subscribe(s,t={}){const f=q(l,s,t.detached,()=>m()),m=_.run(()=>a.watch(()=>o.state.value[e],D=>{(t.flush==="sync"?E:d)&&s({storeId:e,type:R.direct,events:y},D)},N({},b,t)));return f},$dispose:X},n=a.reactive(process.env.NODE_ENV!=="production"||L?N({_hmrPayload:w,_customProperties:a.markRaw(new Set)},T):T);o._s.set(e,n);const g=o._e.run(()=>(_=a.effectScope(),_.run(()=>c())));for(const s in g){const t=g[s];if(a.isRef(t)&&!B(t)||a.isReactive(t))process.env.NODE_ENV!=="production"&&i?k(I.value,s,a.toRef(g,s)):p||(P&&te(t)&&(a.isRef(t)?t.value=P[s]:x(t,P[s])),o.state.value[e][s]=t),process.env.NODE_ENV!=="production"&&w.state.push(s);else if(typeof t=="function"){const f=process.env.NODE_ENV!=="production"&&i?t:M(s,t);g[s]=f,process.env.NODE_ENV!=="production"&&(w.actions[s]=t),u.actions[s]=t}else process.env.NODE_ENV!=="production"&&B(t)&&(w.getters[s]=p?r.getters[s]:t,U&&(g._getters||(g._getters=a.markRaw([]))).push(s))}if(N(n,g),N(a.toRaw(n),g),Object.defineProperty(n,"$state",{get:()=>process.env.NODE_ENV!=="production"&&i?I.value:o.state.value[e],set:s=>{if(process.env.NODE_ENV!=="production"&&i)throw new Error("cannot set hotState");H(t=>{N(t,s)})}}),process.env.NODE_ENV!=="production"&&(n._hotUpdate=a.markRaw(s=>{n._hotUpdating=!0,s._hmrPayload.state.forEach(t=>{if(t in n.$state){const f=s.$state[t],m=n.$state[t];typeof f=="object"&&O(f)&&O(m)?W(f,m):s.$state[t]=m}k(n,t,a.toRef(s.$state,t))}),Object.keys(n.$state).forEach(t=>{t in s.$state||C(n,t)}),d=!1,E=!1,o.state.value[e]=a.toRef(s._hmrPayload,"hotState"),E=!0,a.nextTick().then(()=>{d=!0});for(const t in s._hmrPayload.actions){const f=s[t];k(n,t,M(t,f))}for(const t in s._hmrPayload.getters){const f=s._hmrPayload.getters[t],m=p?a.computed(()=>($(o),f.call(n,n))):f;k(n,t,m)}Object.keys(n._hmrPayload.getters).forEach(t=>{t in s._hmrPayload.getters||C(n,t)}),Object.keys(n._hmrPayload.actions).forEach(t=>{t in s._hmrPayload.actions||C(n,t)}),n._hmrPayload=s._hmrPayload,n._getters=s._getters,n._hotUpdating=!1})),L){const s={writable:!0,configurable:!0,enumerable:!1};["_p","_hmrPayload","_getters","_customProperties"].forEach(t=>{Object.defineProperty(n,t,{value:n[t],...s})})}return o._p.forEach(s=>{if(L){const t=_.run(()=>s({store:n,app:o._a,pinia:o,options:u}));Object.keys(t||{}).forEach(f=>n._customProperties.add(f)),N(n,t)}else N(n,_.run(()=>s({store:n,app:o._a,pinia:o,options:u})))}),process.env.NODE_ENV!=="production"&&n.$state&&typeof n.$state=="object"&&typeof n.$state.constructor=="function"&&!n.$state.constructor.toString().includes("[native code]")&&console.warn(`[\u{1F34D}]: The "state" must be a plain object. It cannot be
	state: () => new MyClass()
Found in store "${n.$id}".`),P&&p&&r.hydrate&&r.hydrate(n.$state,P),d=!0,E=!0,n}function oe(e,c,r){let o,i;const p=typeof c=="function";typeof e=="string"?(o=e,i=p?r:c):(i=e,o=e.id);function _(u,b){const d=a.getCurrentInstance();if(u=(process.env.NODE_ENV==="test"&&j&&j._testing?null:u)||d&&a.inject(K),u&&$(u),process.env.NODE_ENV!=="production"&&!j)throw new Error(`[\u{1F34D}]: getActivePinia was called with no active Pinia. Did you forget to install pinia?
	const pinia = createPinia()
	app.use(pinia)
This will fail in production.`);u=j,u._s.has(o)||(p?A(o,c,i,u):J(o,i,u),process.env.NODE_ENV!=="production"&&(_._pinia=u));const E=u._s.get(o);if(process.env.NODE_ENV!=="production"&&b){const l="__hot:"+o,h=p?A(l,c,i,u,!0):J(l,N({},i),u,!0);b._hotUpdate(h),delete u.state.value[l],u._s.delete(l)}if(process.env.NODE_ENV!=="production"&&U&&d&&d.proxy&&!b){const l=d.proxy,h="_pStores"in l?l._pStores:l._pStores={};h[o]=E}return E}return _.$id=o,_}const se=oe({id:"counter",state:()=>({counter:0}),getters:{doubleCount:e=>e.counter*2},actions:{increment(){this.counter++}}}),ne=[{path:"/about",name:"about",component:()=>Promise.resolve().then(()=>require("./AboutView.e96ab10d.js"))}];class re{constructor(c){c.Store.registerBatch([se]),c.Router.registerBatch(ne)}}exports.Home=re;
